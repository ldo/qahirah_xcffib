This module wraps the [xcffib Python binding](https://github.com/tych0/xcffib)
for XCB as an extension to Qahirah ([GitLab](https://gitlab.com/ldo/qahirah),
[GitHub](https://github.com/ldo/qahirah)), my Python binding for the
Cairo graphics library. You will need to have that installed as well.

This module subclasses `qahirah.XCBSurface` with overriding create
methods that take `Connection` and other objects as defined by xcffib
and does appropriate conversions before passing them to the
corresponding methods in the base class. This allows you to use
Cairo to do onscreen drawing via Qahirah. It also interfaces to the
standard `asyncio` event loop API introduced in Python 3.5, providing
useful functions for handling events and creating cursors, among other
things.

The aim behind `qahirah_xcffib` is not to create an actual GUI
toolkit; it is just meant to be a modest set of convenience routines
to allow experimenting with on-screen drawing using my Python
bindings for Cairo and related font/graphics APIs.

For reference information on X11 protocols, see [the links at
x.org](https://www.x.org/releases/X11R7.7/doc/index.html).


Basic Operation
===============

The base object for managing a connection to the X11 server is
the `Connection`. This wraps an `xcffib` `Connection` object and
also makes use of an `asyncio` event loop for managing asynchronous
calls.

You can install one or more _event filters_ into a `Connection`.
Each filter is invoked every time an X11 event is received on the
connection. Each event is passed to every filter on the `Connection`.

Building on top of this is the `Window` object, which wraps an
X11 window. Remember that the _window_ concept in X11 also subsumes
GUI widgets within a window: these can be represented as subwindows
within a parent window. A `Window` can also have its own event
filters installed; these will only be invoked for events that
look like they have to do with that window; each filter installed
can also specify the set of events which it wants to see, ignoring
all others.

There are various convenience routines for creating Cairo XCB
surfaces associated with X11 drawables. This allows you to
conveniently use Cairo to draw into such drawables, for display
on-screen. Besides drawing into X11 windows, you can also render
Cairo graphics into X11 pixmaps, which are useful for defining
custom cursors, for example.

However, note that X11 cursors (at least in the core protocol) only
allow one bit of image information, plus one bit of transparency
information, per pixel. Cairo does not seem able to draw properly into
1-bit-deep X11 surfaces, so I provide convenience calls to allow you
to do all drawing into 24-bit-deep pixmaps, which are then
down-converted to 1 bit per pixel for use in creating cursors.

Such down-conversion is done by using the X11 `CopyPlane` operation
with a `GContext`. While X11 provides a whole set of operations for
drawing controlled by `GContext` objects, I only support a minimal
subset of these, just sufficient to interface between Cairo and X11.
The expectation is that you will want to use Cairo to do the bulk of
your actual drawing.


Convenience Classes
===================

Besides the above, a number of additional conveniences help to
simplify various aspects of X11 programming.

To start with, the X11 `CreateWindow` call lets you specify a
set of attributes in the form of a _value mask_ followed by a
_value list_. The value mask is a bitmask where each 1 bit indicates
that the corresponding attribute is present in the list. This way,
the list can be variable-length, but attributes that are present
have to be specified in order of their corresponding bit position
in the mask.

I found this somewhat awkward when writing actual programs. So what I
did in the `Window.create()` method was let you specify a sequence of
(_bit number_, _attribute value_) pairs instead. The bit numbers have
symbolic names as defined in the custom `WINATTR` enumeration. You can
specify these pairs in any order in the sequence; they will be
automatically sorted into order of increasing bit number, after which
the bit numbers are combined into the appropriate value mask, and the
values extracted into the corresponding value list, to be passed to
the underlying X11 call.

Similar conversions of bit-number/attribute-value pairs into
value-mask/value-list structures are done for the attributes to
the `ConfigWindow` call, as well as for attributes specified when
creating `GContext` objects.

I also provide the `AtomCache` class, for caching mappings between
X11 “atom” name strings and the corresponding ID codes, and the
`KeyMapping` class, which queries the X11 server for its current
keyboard mapping and modifier mapping, and translates these into
a convenient form for dealing with actual keypress events.

Another convenience class is the `ButtonHandler`, which handles
the common tasks in managing clickable buttons, including highlighting
while the mouse is down within the button, and only invoking the
click action if the mouse button is released while the mouse is
within the actual button.


Examples
========

To see examples of this module in action, see my `qahirah_xcffib_examples`
project ([GitLab](https://gitlab.com/ldo/qahirah_xcffib_examples),
[GitHub](https://github.com/ldo/qahirah_xcffib_examples)).

Lawrence D'Oliveiro <ldo@geek-central.gen.nz>
2022 March 31
